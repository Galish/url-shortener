// Package osexitcheckanalyzer implement a custom analyzer that checks
// for a direct os.Exit call in the main function of the main package.
package osexitcheckanalyzer

import (
	"go/ast"
	"strings"

	"golang.org/x/tools/go/analysis"
)

const (
	warningMessage      = "illegal `os.Exit` call"
	prefixCodeGenerated = "// Code generated by"
)

// New returns a new `osexitinmaincheck` analyzer.
func New() *analysis.Analyzer {
	return &analysis.Analyzer{
		Name: "osexitinmaincheck",
		Doc:  "check for direct os.Exit call in the main function of the main package",
		Run:  run,
	}
}

func run(pass *analysis.Pass) (interface{}, error) {
	for _, file := range pass.Files {
		if !isMainPackage(file) {
			continue
		}

		var parents []*ast.Node

		ast.Inspect(file, func(node ast.Node) bool {
			if node == nil {
				parents = parents[:len(parents)-1]
				return true
			}

			parents = append(parents, &node)

			c, ok := node.(*ast.CallExpr)
			if ok && isOSExitCall(c) && isMainFunc(parents) {
				pass.Reportf(c.Fun.Pos(), warningMessage)
			}

			return true
		})
	}

	return nil, nil
}

func isMainPackage(file *ast.File) bool {
	if file.Name.String() != "main" {
		return false
	}

	if len(file.Comments) != 0 {
		return !strings.HasPrefix(file.Comments[0].List[0].Text, "// Code generated by")
	}

	return true
}

func isMainFunc(chain []*ast.Node) bool {
	for i := len(chain) - 1; i >= 0; i-- {
		node := *chain[i]

		s, ok := node.(*ast.FuncDecl)
		if !ok {
			continue
		}

		return s.Name.String() == "main"
	}

	return false
}

func isOSExitCall(call *ast.CallExpr) bool {
	s, ok := call.Fun.(*ast.SelectorExpr)
	if !ok || s.Sel.Name != "Exit" {
		return false
	}

	if x, ok := s.X.(*ast.Ident); !ok || x.Name != "os" {
		return false
	}

	return true
}
